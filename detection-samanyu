import cv2
import threading
import time
import os
import numpy as np
import MQTT
import Camera as cam

count_lock = threading.Lock()  # Lock for count variable
car_count_lock = threading.Lock()  # Lock for car_count variable

count = 1
car_count = 1

def car_detection(frame, frame_name):
    global car_count
    
    grey = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(grey, (5, 5), 0)
    dilated = cv2.dilate(blur, np.ones((3, 3)))
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))
    closing = cv2.morphologyEx(dilated, cv2.MORPH_CLOSE, kernel)

    car_cascade_src = 'cars.xml'
    car_cascade = cv2.CascadeClassifier(car_cascade_src)
    cars = car_cascade.detectMultiScale(closing, 1.1, 1)

    cnt = len(cars)
    print(f"{cnt} cars found for {frame_name}")

    with car_count_lock:
        car_count += cnt

    # Publish car count only if a new frame is processed
    if cnt > 0:
        client.publish("ESIOT", car_count, qos=1)

def capture_images(video_source, batch_size):
    cap = cv2.VideoCapture(video_source)

    if not cap.isOpened():
        print("Error: Unable to open video source.")
        return

    photo_counter = 0
    last_capture_time = time.time()
    start_time = time.time()

    while True:
        ret, frame = cap.read()

        if not ret:
            print("Error: Frames are not coming in as expected.")
            break

        current_time = time.time()

        if current_time - last_capture_time >= batch_size:
            photo_counter += 1
            frame_name = f"images/{photo_counter}.jpeg"

            # Perform car detection
            car_detection(frame, frame_name)

            last_capture_time = current_time

            cv2.imwrite(frame_name, frame)
            print(f"Photo {photo_counter} captured.")

        cv2.imshow('Frame', frame)
        if cv2.waitKey(1) == ord('q'):
            break

    end_time = time.time() - start_time
    print(f"Total Runtime: {end_time} seconds")

    cap.release()
    cv2.destroyAllWindows()

def car_detection_repeated(batch_size, total_images):
    global count
    
    for i in range(total_images):
        # Increase count
        with count_lock:
            count += 1

        time.sleep(2)

if __name__ == "__main__":
    if not os.path.exists("images"):
        os.makedirs("images")

    # Start capturing images
    t1 = threading.Thread(target=capture_images, args=("http://192.168.86.69:8084/?action=stream", 3))

    # Start car detection
    t2 = threading.Thread(target=car_detection_repeated, args=(1, 100))

    # Initialize MQTT client
    client = MQTT.MQTTClient("192.168.86.69", 1884)
    client.connect()
    
    t1.start()
    print("t1 started")

    t2.start()
    print("t2 started")
    
    # Join threads
    t1.join()
    t2.join()
